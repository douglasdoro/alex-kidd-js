function setup(){createCanvas(config.canvas.width,config.canvas.height),frameRate(config.frameFate),game=new Game}function keyPressed(){game.keyPressed(key)}function keyReleased(){game.keyReleased(key)}function draw(){background("#09adff"),game.draw()}
let game,config,walkingImage,birdImage,ghostImage,deadImage,jumpImage,crouchedImage,jumpSound,gameOverSound,stageOneImage,singleTreeImage,cloudImage,mainThemeSound;function preload(){config=loadJSON("config/config.json",fillConfigAfterLoad)}function fillConfigAfterLoad(e){walkingImage=loadImage(config.character.walking.imagePath),jumpImage=loadImage(config.character.jumping.imagePath),birdImage=loadImage(config.enemies.monsterBird.imagePath),ghostImage=loadImage(config.enemies.ghost.imagePath),deadImage=loadImage(config.character.dead.imagePath),crouchedImage=loadImage(config.character.crouched.imagePath),stageOneImage=loadImage(config.stage.one.ground.imagePath),singleTreeImage=loadImage(config.stage.one.elements.tree.imagePath),cloudImage=loadImage(config.stage.one.elements.cloud.imagePath),jumpSound=loadSound(config.character.soundPathJump),gameOverSound=loadSound(config.character.soundPathGameOver),mainThemeSound=loadSound(config.mainThemeSoundPath)}
class Animation{constructor(i,t,s,h,e,a){this.image=i,this.x=t,this.y=s,this.width=h,this.height=e,this.spriteMap=a,this.frame=0,this.speedAnimation=.1}draw(){noFill(),rect(this.x,this.y,this.width,this.height),image(this.image,this.x,this.y,this.width,this.height,this.spriteMap.captureX||0,this.spriteMap.captureY||0,this.spriteMap.fillX,this.spriteMap.fillY),this.animate()}animate(){this.spriteMap.captureX=this.spriteMap.frames[this.frame.toFixed()],this.frame>=this.spriteMap.frames.length-1?this.frame=0:this.frame=this.frame+this.speedAnimation}}
class Character extends Animation{constructor(i,t,h,a,e,s){super(i,t,h,a,e,s),this.speedAnimation=.23,this.isDead=!1,this.isJumping=!1,this.isCrouching=!1,this.upSpeed=0,this.gravity=3,this.defaultPositionY=this.y-this.height,this.yVariation=0}jump(){if(this.isJumping||this.isDead)return!1;this.upSpeed=-30,this.isJumping=!0,this.changeAnimationImage("jumping"),jumpSound.play()}crouched(){if(this.isJumping||this.isDead)return!1;this.isCrouching?(this.yVariation=0,this.changeAnimationImage("walking")):(this.changeAnimationImage("crouched"),this.yVariation=11),this.isCrouching=!this.isCrouching}applyGravity(){this.y=this.y+this.upSpeed,this.upSpeed=this.upSpeed+this.gravity;const i=this.y>this.defaultPositionY+this.yVariation;i&&(this.y=this.defaultPositionY+this.yVariation);this.isJumping&&i&&(this.isJumping=!1,this.changeAnimationImage("walking"))}dead(){this.upSpeed=-5,this.isDead||(gameOverSound.play(),gameOverSound.stop(3),this.changeAnimationImage("dead"),this.isDead=!0)}changeAnimationImage(i){switch(i){case"jumping":this.image=jumpImage,this.width=config.character.jumping.width,this.height=config.character.jumping.height,this.spriteMap=config.character.jumping.spriteMap;break;case"walking":this.image=walkingImage,this.width=config.character.walking.width,this.height=config.character.walking.height,this.spriteMap=config.character.walking.spriteMap;break;case"dead":this.image=deadImage,this.width=config.character.dead.width,this.height=config.character.dead.height,this.spriteMap=config.character.dead.spriteMap;break;case"crouched":this.image=crouchedImage,this.width=config.character.crouched.width,this.height=config.character.crouched.height,this.spriteMap=config.character.crouched.spriteMap}}_calculateJumpHeight(i,t,h){let a=h,e=i/t;for(let i=0;i<=e;i++)a-=t*i;return a}}
class Enemy extends Animation{constructor(s,t,i,h,e,d){super(s,t,i,h,e,d),this.speed=2}move(){this.x=this.x-this.speed;this.x-this.width<-this.width&&(this.x=config.canvas.width+this.width)}}
class Game{constructor(){this.character,this.enemies,this.isCollide,this.setup()}setup(){this.isCollide=!1,this.stage=new Stage,this.character=this._buildCharacter(config.character.x,this.stage.defaultPlayerY),this.enemies=this._buildEnemies()}draw(){if(this.character.applyGravity(),this.stage.draw(),this.isCollide)this.character.dead();else for(let e=0;e<this.enemies.length&&(this.enemies[e].draw(),this.enemies[e].move(),this.isCollide=this.checkIfTheyCollide(this.character,this.enemies[e]),!this.isCollide);e++);this.character.draw()}checkIfTheyCollide(e,i){return collideRectRect(e.x,e.y,e.width,e.height,i.x,i.y,i.width,i.height)}keyPressed(e){"ArrowUp"===e&&this.character.jump(),"ArrowDown"===e&&this.character.crouched()}keyReleased(e){"ArrowDown"===e&&this.character.crouched()}_buildCharacter(e,i){return new Character(walkingImage,e,i,config.character.walking.width,config.character.walking.height,config.character.walking.spriteMap)}_buildEnemies(){const e=[],i=new Enemy(birdImage,config.enemies.monsterBird.x,config.enemies.monsterBird.y,config.enemies.monsterBird.width,config.enemies.monsterBird.height,config.enemies.monsterBird.spriteMap),t=new Enemy(ghostImage,config.enemies.ghost.x,config.enemies.ghost.y,config.enemies.ghost.width,config.enemies.ghost.height,config.enemies.ghost.spriteMap);return e.push(i,t),e}}
class Scenario{constructor(){this.groundInfo,this.groundY,this.groundCollection,this.groundX,this._elements,this.setup()}setup(){this.groundInfo=config.stage.one.ground,this.groundY=config.canvas.height-this.groundInfo.height,this.groundCollection=this._buildGround(),this.groundX=0,this._elements=config.stage.one.elements.collection}elements(){for(let t=0;t<this._elements.length;t++)"tree"===this._elements[t].type&&(this._elements[t].image=singleTreeImage),"cloud"===this._elements[t].type&&(this._elements[t].image=cloudImage),"right"!==this._elements[t].direction?(this._elements[t].initialX=config.canvas.width,this._drawElementRightToLeft(this._elements[t])):(this._elements[t].initialX=0,this._drawElementLeftToRight(this._elements[t]))}ground(){this.groundX=this.groundX-this.groundInfo.speed,this.groundCollection.forEach(t=>{const e=t+this.groundX;image(stageOneImage,e,this.groundY);this.groundX<-config.canvas.width&&(this.groundX=0)})}_drawElementLeftToRight(t){t.y||(t.y=this.groundY-t.height),image(t.image,t.x,t.y,t.width,t.height),t.x=t.x+parseFloat(t.speed);t.x>config.canvas.width+t.width&&(t.x=t.initialX-t.width)}_drawElementRightToLeft(t){t.y||(t.y=this.groundY-t.height),image(t.image,t.x,t.y,t.width,t.height),t.x=t.x-parseFloat(t.speed);t.x<-t.width&&(t.x=t.initialX)}_buildGround(){let t=0;const e=[];for(;t<2*config.canvas.width;)e.push(t),t+=this.groundInfo.width;return e}}
class Stage{constructor(){this.scenario=new Scenario,this.defaultPlayerY=config.canvas.height-config.stage.one.defaultPlayerY}draw(){this.scenario.ground(),this.scenario.elements()}}